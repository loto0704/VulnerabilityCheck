import os.path
import sys
import json
import ulid
from db_connect import ObjectRelationalMapping
from chardet import detect

CONFIG_FILE = "config.json"


def path_get():
    json_open = open(CONFIG_FILE, 'r')
    json_load = json.load(json_open)
    json_open.close()

    return json_load


# データベースがあるか確認：ない場合→作成
def check_db(db_path):
    if not os.path.exists(db_path):
        with open(db_path, "w") as f:
            f.write("")


def tabel_check(db_path: str) -> None:
    connect = ObjectRelationalMapping(db_path)
    env_tables_sql = '''SELECT name
        FROM sqlite_master
        WHERE type='table';'''
    table_data = connect.db_execute(env_tables_sql).fetchall()
    connect.db_close()
    table_list = []
    for i in range(len(table_data)):
        table_list.append(table_data[i][0])

    # 「environments」テーブルの確認：ない場合→作成
    if not ("environments" in table_list):
        env_connect = ObjectRelationalMapping(db_path)
        crete_env_sql = '''CREATE TABLE environments(
            name TEXT PRIMARY KEY,
            description TEXT,
            create_date INTEGER);'''
        env_connect.db_execute(crete_env_sql)
        env_connect.db_commit()
        env_connect.db_close()

    # 「libraries」テーブルの確認：ない場合→作成
    if not ("libraries" in table_list):
        libraries_connect = ObjectRelationalMapping(db_path)
        create_library_sql = '''CREATE TABLE libraries(
                id TEXT PRIMARY KEY,
                library_name TEXT NOT NULL,
                search_library_name TEXT,
                library_ver TEXT NOT NULL,
                search_library_ver TEXT,
                security_advisories TEXT,
                search_url TEXT,
                check_last_date TEXT);'''
        libraries_connect.db_execute(create_library_sql)
        libraries_connect.db_commit()
        libraries_connect.db_close()

    # 「library_tag」テーブルの確認：ない場合→作成
    if not ("library_tag" in table_list):
        tag_connect = ObjectRelationalMapping(db_path)
        create_library_tag_sql = '''CREATE TABLE library_tag(
                id TEXT PRIMARY KEY,
                environments_name TEXT,
                library_id TEXT,
                create_date TEXT NOT NULL,
                foreign key(environments_name) references environments(name),
                foreign key(library_id) references libraries(id));'''
        tag_connect.db_execute(create_library_tag_sql)
        tag_connect.db_commit()
        tag_connect.db_close()


def txt_read(requirements_path):
    data = []
    with open("requirements.txt", 'rb') as bf:  # バイナリーで読み込み
        binary_data = bf.read()
        encode_data = detect(binary_data)

    with open(requirements_path, mode='r', encoding=encode_data['encoding']) as f:
        for line in f.readlines():
            library_id = ulid.ulid()
            data_tuple = (library_id, line.split('==')[0], line.split('==')[1].replace('\n', ""))
            data.append(data_tuple)

    return data


# データ挿入:ライブラリ
def insert_library(db_path: str, data: list):
    connect = ObjectRelationalMapping(db_path)
    sql = '''INSERT INTO libraries(id, library_name, library_ver) VALUES(?, ?, ?);'''
    connect.db_execute_many(sql, data)
    connect.db_commit()
    connect.db_close()


# 引数確認
def argument_check():
    # requirementsファイルの確認
    try:
        requirements_path = sys.argv[1]
    except IndexError:
        print("引数が正しく指定されてません")
        exit()
    else:
        if not os.path.exists(requirements_path):
            print("Pythonパッケージリストのファイルが確認できませんでした")
            exit()

    # 仮想環境名の確認
    try:
        venv_name = sys.argv[2]
    except IndexError:
        print("仮想環境名が確認できませんでした")
        exit()

    return requirements_path, venv_name


def main():
    requirements_path, venv_name = argument_check()

    json_data = path_get()
    db_path = json_data["db_path"]
    if db_path == "":
        db_path = "library.sqlite"

    # テーブルの有無確認
    tabel_check(db_path)

    # requirements.txt読み込み
    library_data = txt_read(requirements_path)

    # ライブラリデータインポート（SQL実行）
    insert_library(db_path, library_data)


if __name__ == '__main__':
    main()
